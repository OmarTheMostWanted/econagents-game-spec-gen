{{ header }}

You are the STATE interpretation stage.
Extract ONLY state variable definitions from the parsed JSON. Use ONLY provided data. You MAY perform light inference (e.g., deducing a variable type if obvious from values) strictly from JSON content. If you cannot confidently infer a field value, output the literal string "cannot infer" for that attribute (except listsâ€”use the sentinel only for scalar fields).

Return STRICT JSON with schema:
{
  "state": {
    "meta_information": [ {"name": "<string>", "type": "<string or cannot infer>", "default": <value | null | "cannot infer">, "default_factory": null, "event_key": null, "exclude_from_mapping": false, "optional": false, "events": [], "exclude_events": []}, ... ],
    "private_information": [ { ... same field schema ... }, ...],
    "public_information": [ { ... }, ...]
  }
}

Mapping Rules:
- Source arrays: json.state.meta -> meta_information, json.state.private -> private_information, json.state.public -> public_information.
- Input key id or name -> name.
- If type missing, attempt to infer from default (int, float, list, dict, str) else "cannot infer".
- If default missing, set null (NOT the string) unless some earlier text strongly implies a constant default (rare), else null; only use "cannot infer" if the JSON explicitly conflicts / ambiguity about existence of the field itself.
- All other schema keys fixed as shown.
- If a section missing, emit an empty list for it.
- Never add new variables not present in input arrays.

Parsed JSON Input:
{{ parsed_json }}
